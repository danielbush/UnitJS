<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--
/* 
 * This is a source file for UnitJS a unit testing framework
 * for javascript.
 * Copyright (C) 2008 Daniel Bush
 * This program is distributed under the terms of the GNU
 * General Public License.  A copy of the license should be
 * enclosed with this project in the file LICENSE.  If not
 * see <http://www.gnu.org/licenses/>.
 *
 * Substantial parts of this code were taken from the JSUnit
 * project.  The Initial Developer of the Original Code is
 * Edward Hieatt, edward@jsunit.net.  Portions created by
 * the Initial Developer are Copyright (C) 2003 the Initial
 * Developer.  All Rights Reserved.
 *
 */
-->

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>UnitJS Assertion Tests</title>
<link rel="stylesheet" type="text/css"
      href="../defaultPrinter.css" media="screen" />
<script language="JavaScript" type="text/javascript"
        src="../unitjs.js"></script>
<script language="JavaScript" type="text/javascript"
        src="../unitjs.printers.js"></script>
<script language="JavaScript" type="text/javascript">

var U       = $web17_com_au$.unitJS;
var A       = $web17_com_au$.unitJS.assertions;
var utils   = $web17_com_au$.unitJS.utils;
var Printer = $web17_com_au$.unitJS.printers.DefaultPrinter;
var DummyPrinter = $web17_com_au$.unitJS.printers.DummyPrinter;
var Sections = $web17_com_au$.unitJS.Sections;
var Section  = $web17_com_au$.unitJS.Section;

var sections = new Sections();
var stmt;
var s,s1,s2,s3,s4,s5;
var printer;
var setupChecker = {val:null};
var teardownChecker;

// TODO: 4-Jul-09
stmt = 'Runner should only run the tests in runner.only if set';
stmt = 'Runner should run all tests if runner.only is null or []';
stmt = 'runner.onlyFound should be set to true if runner finds (and runs) a test that matches one in runner.only';
stmt = 'runner.run should reset runner.onlyFound to false at beginning of each run';


//------------------------------------------------
s = sections.add('Assertion tests');

stmt = 'Test assert';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  A.assert("true should be true", true);
  A.assert(true);
}

stmt = 'Test assertTrue';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    A.assertTrue("true should be true", true);
    A.assertTrue(true);
}

stmt = 'Test assertFalse';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    A.assertFalse("false should be false", false);
    A.assertFalse(false);
}

stmt = 'Test assertEquals';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    A.assertEquals("1 should equal 1", 1, 1);
    A.assertEquals(1, 1);
}

stmt = 'Test assertNotEquals';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    A.assertNotEquals("1 should not equal 2", 1, 2);
    A.assertNotEquals(1, 2);
}

stmt = 'Test assertNull';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    A.assertNull("null should be null", null);
    A.assertNull(null);
}

stmt = 'Test assertNotNull';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    A.assertNotNull("1 should not be null", 1);
    A.assertNotNull(1);
}

stmt = 'Test assertUndefined';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    var myVar;
    A.assertUndefined(
      "A declared but unassigned variable should have the undefined value", 
      myVar);
    A.assertUndefined(myVar);
}

stmt = 'Test assertNotUndefined';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    A.assertNotUndefined("1 should not be undefined", 1);
    A.assertNotUndefined(1);
}

stmt = 'Test assertNaN';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    A.assertNaN("a string should not be a number", "string");
    A.assertNaN("string");
}

stmt = 'Test assertNotNaN';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    A.assertNotNaN("1 should not be not a number", 1);
    A.assertNotNaN(1);
}

//--------------------------------------------------
s2 = s.subsections.add('Assertion utilities');
stmt = 'Test utils.fail';
s2.testOrder.push(stmt);
s2.tests[stmt] = function() {
    var excep = null;
    try {
        utils.fail("Failure message",'');
    } catch (e) {
        excep = e;
    }
    A.assertFailure(
      "fail(string) should throw a failure error object",
      excep);
}

stmt = 'Test too few arguments to assertion functions';
s2.testOrder.push(stmt);
s2.tests[stmt] = function() {
    var excep = null;
    try {
        A.assert();
    } catch (e1) {
        excep = e1;
    }
    A.assertError(
      "Calling an assertion function with too few arguments should throw an exception",
      excep);
}

stmt = 'Test too many arguments to assertion functions';
s2.testOrder.push(stmt);
s2.tests[stmt] = function() {
    var excep = null;
    try {
        A.assertEquals("A comment", true, true, true);
    } catch (e2) {
        excep = e2;
    }
    A.assertError(
      "Calling an assertion function with too many arguments should throw an exception",
      excep);
}

stmt = 'Test invalid argument comment type';
s2.testOrder.push(stmt);
s2.tests[stmt] = function() {
    var excep = null;
    try {
        A.assertNull(1, true);
    } catch (e3) {
        excep = e3;
    }
    A.assertError(
      "Calling an assertion function with a non-string comment should throw an exception",
      excep);
}

stmt = 'Test invalid boolean test / argument type';
s2.testOrder.push(stmt);
s2.tests[stmt] = function() {
    var excep = null;
    try {
        A.assert("string");
    } catch (e) {
        excep = e;
    }
    A.assertError(
      "Calling an assertion function with an invalid argument should throw an exception",
      excep);
}

stmt = 'Test assertArrayEquals';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    var array1 = Array();
    array1[0] = "foo";
    array1[1] = "bar";
    array1[2] = "foobar";
    var array2 = Array();
    array2[0] = "foo";
    array2[1] = "bar";
    array2[2] = "foobar";
    var array3 = Array();
    array3[0] = "foo";
    array3[1] = "bar";
    var array4 = Array();
    array4[0] = "bar";
    array4[1] = "foo";
    array4[2] = "foobar";

    A.assertArrayEquals(array1, array1);
    A.assertArrayEquals(array1, array2);
    try {
        A.assertArrayEquals(array1, array3);
        utils.fail("Should not be equal",'');
    } catch (e) {
        A.assertFailure("Should be a failure error object", e);
        if (e.comment == "Call to fail()")
            utils.fail(e.comment + e.message,''); //tried fail is also caught
    }
    try {
        A.assertArrayEquals(array1, array4);
        utils.fail("Should not be equal",'');
    } catch (e) {
        A.assertFailure("Should be a failure error object", e);
        if (e.comment == "Call to fail()")
            utils.fail(e.comment + e.message,''); //tried fail is also caught
    }
    var array5 = ['foo', 'bar', ['nested', 'bar'], 'foobar'];
    var array6 = ['foo', 'bar', ['nested', 'bar'], 'foobar'];
    var array7 = ['foo', 'bar', ['nested', 'foo'], 'foobar'];
    A.assertArrayEquals('Equal nested arrays', array5, array6);
    try
    {
        A.assertArrayEquals(array5, array7);
        var failure = 'Differing nested arrays found to be equal';
        utils.fail(failure,'');
    }
    catch (e)
    {
        A.assertFailure("Should be a failure error object", e);
        if (e.message == failure)
            utils.fail(e.message,'');
    }
}

stmt = 'Test assertObjectEquals';
s.testOrder.push(stmt);
s.tests[stmt] = function()
{
    var failure;
    var o1 = {foo:'bar'};
    var o2 = {foo:'bar'};
    A.assertObjectEquals('Single object', o1, o1);
    A.assertObjectEquals('Same objects', o1, o2);
    var o3 = {foo:'foo'};
    var o4 = {foo:'foo',
        bar: function () {
            this.foo = 'bar';
            delete this.bar
        }};
    var o5 = {foo:'foo',
        bar: function () {
            this.foo = 'foo';
            delete this.bar
        }};
    try
    {
        A.assertObjectEquals(o1, o3);
        utils.fail(failure = 'Simple differing objects found to be the same','');
    }
    catch (e)
    {
        A.assertFailure("Should be a failure error object", e);
        if (e.message == failure)
            utils.fail(e.message,'');
    }
    try
    {
        A.assertObjectEquals(o4, o5);
        utils.fail(failure = 'Objects with different methods found to be the same','');
    }
    catch (e)
    {
        A.assertFailure("Should be a failure error object", e);
        if (e.message == failure)
            utils.fail(e.message,'');
    }

    o4.bar();
    A.assertObjectEquals('Different objects, made to be the same', o1, o4);
    try
    {
        A.assertObjectEquals({ts:new Date()}, {ts:new Date()});
        utils.fail(failure = 'Objects with different Date attributes found to be the same','');
    }
    catch (e)
    {
        A.assertFailure("Should be a failure error object", e);
        if (e.message == failure)
            utils.fail(e.message,'');
    }
    try
    {
        A.assertObjectEquals(new Date(), new Date());
        utils.fail(failure = 'Different Date objects found to be the same','');
    }
    catch (e)
    {
        A.assertFailure("Should be a failure error object", e);
        if (e.message == failure)
            utils.fail(e.message,'');
    }
    A.assertObjectEquals(/a/, new RegExp('a'));
    A.assertObjectEquals(/a/i, new RegExp('a', 'i'));

    try
    {
        A.assertObjectEquals(/a/i, new RegExp('a', 'g'));
        utils.fail(failure = 'RegExp with different flags found to be the same','');
    }
    catch (e)
    {
        A.assertFailure("Should be a failure error object", e);
        if (e.message == failure)
            utils.fail(e.message,'');
    }
    try
    {
        A.assertObjectEquals(/a/, new RegExp('b'));
        utils.fail(failure = 'RegExp with different patterns found to be the same','');
    }
    catch (e)
    {
        A.assertFailure("Should be a failure error object", e);
        if (e.message == failure)
            utils.fail(e.message,'');
    }
}

stmt = 'Test assertObjectEquals for strings';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    var s1 = 'string1';
    var s2 = 'string1';
    var newS1 = new String('string1');
    A.assertObjectEquals('Same Strings', s1, s2);
    A.assertObjectEquals('Same Strings 1 with new', s1, newS1);
}

stmt = 'Test assertObjectEquals for numbers';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    var failure;
    var n1 = 1;
    var n2 = 1;
    var newN1 = new Number(1);
    A.assertObjectEquals('Same Numbers', n1, n2);
    A.assertObjectEquals('Same Numbers 1 with new', n1, newN1);
    var n3 = 2;
    var newN3 = new Number(2);
    try
    {
        A.assertObjectEquals(n1, n3);
        utils.fail(failure = 'Different Numbers','');
    }
    catch (e)
    {
        A.assertFailure("Should be a failure error object", e);
        if (e.message == failure)
            utils.fail(e.message,'');
    }
    try
    {
        A.assertObjectEquals(newN1, newN3);
        utils.fail(failure = 'Different New Numbers','');
    }
    catch (e)
    {
        A.assertFailure("Should be a failure error object", e);
        if (e.message == failure)
            utils.fail(e.message,'');
    }
}

stmt = 'Test assertEvaluatesToTrue';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    A.assertEvaluatesToTrue("foo");
    A.assertEvaluatesToTrue(true);
    A.assertEvaluatesToTrue(1);
    try {
        A.assertEvaluatesToTrue(null);
        utils.fail("Should have thrown a failure error object",'');
    } catch (e) {
        A.assertFailure("Should be a failure error object", e);
    }
}

stmt = 'Test assertEvaluatesToFalse';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    A.assertEvaluatesToFalse("");
    A.assertEvaluatesToFalse(null);
    A.assertEvaluatesToFalse(false);
    A.assertEvaluatesToFalse(0);
    try {
        A.assertEvaluatesToFalse("foo");
        utils.fail("Should have thrown a failure error object",'');
    } catch (e) {
        A.assertFailure("Should be a failure error object", e);
    }
}

stmt = 'Test assertHTMLEquals';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    A.assertHTMLEquals("<div id=mydiv>foobar</div>", "<div id='mydiv'>foobar</div>");
    A.assertHTMLEquals("<p/>", "<p></p>");
    A.assertHTMLEquals("foo bar", "foo bar");
    A.assertHTMLEquals("a comment", "<p id='foo'>foo bar</p>", "<p id=foo>foo bar</p>");
}

stmt = 'Test assertHashEquals';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    var hash1 = new Array();
    hash1["key1"] = "value1";
    hash1["key2"] = "value2";

    var hash2 = new Array();
    try {
        A.assertHashEquals(hash1, hash2);
        utils.fail('','');
    } catch (e) {
        A.assertFailure("hash2 is empty", e);
    }
    hash2["key1"] = "value1";
    try {
        A.assertHashEquals(hash1, hash2);
        utils.fail('','');
    } catch (e) {
        A.assertFailure("hash2 is a of a different size", e);
    }
    hash2["key2"] = "foo";
    try {
        A.assertHashEquals(hash1, hash2);
        utils.fail('','');
    } catch (e) {
        A.assertFailure("hash2 has different values", e);
    }
    hash2["key2"] = "value2";
    A.assertHashEquals(hash1, hash2);
}

stmt = 'Test assertRoughlyEquals';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    A.assertRoughlyEquals(1, 1.1, 0.5);
    A.assertRoughlyEquals(1, 5, 6);
    A.assertRoughlyEquals(-4, -5, 2);
    A.assertRoughlyEquals(-0.5, 0.1, 0.7);
    try {
        A.assertRoughlyEquals(1, 2, 0.5);
    } catch (e) {
        A.assertFailure("1 and 2 are more than 0.5 apart", e);
    }
}

stmt = 'Test assertContains';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
    A.assertContains("foo", "foobar");
    A.assertContains("ooba", "foobar");
    A.assertContains("bar", "foobar");
}

//------------------------------------------------
s = sections.add('runner.only');

stmt = 'runner.only runs only selected test'
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  var unitjs = U.spawn();
  var AA = unitjs.assertions;
  var Section = unitjs.Section;
  var section;
  var sections = new unitjs.Sections();
  var s1,s2,s3;
  var stmt;
  var f1,f2;
  var stats;

  s1 = sections.add('sec 1');

  stmt = 'test 1'
  s1.testOrder.push(stmt);
  s1.tests[stmt] = function() {
    AA.assert(true);
  }
  stmt = 'test 2'
  s1.testOrder.push(stmt);
  f1 = s1.tests[stmt] = function() {
    AA.assert(true);
  }
  unitjs.runner.only.push(f1);
  stats = unitjs.runner.sections.run(sections,new DummyPrinter());
  A.assertEquals(1,stats.tests);
    // Would be 2.

}

//------------------------------------------------
s = sections.add('stats');

stmt = 'stats show that 3rd assertion fails';
s.testOrder.push(stmt);
s.tests[stmt] = function(STATS) {
    A.assert(true);
    A.assert(true);
    try {
      A.assert(false);
    } catch(e) { }
    A.assert(STATS.current.assertion_count==3);
}

stmt = 'stats show that error occurs on or after 2nd assertion';
s.testOrder.push(stmt);
s.tests[stmt] = function(STATS) {
    try {
      A.assert(true);
      A.assert(true);
      throw new Error('Unexpected error here!');
    } catch(e) { }
    A.assert(STATS.current.assertion_count==2);
}

stmt = 'Test assertion count for a test';
s.testOrder.push(stmt);
s.tests[stmt] = function(STATS) {
    A.assertEquals(0,STATS.current.assertion_count);
    A.assertEquals(1,STATS.current.assertion_count);
    A.assertEquals(2,STATS.current.assertion_count);
    // etc...
}

stmt = 'runner.sections.run returns a stats object for all section instances in sections'
s.testOrder.push(stmt);
s.tests[stmt] = function() {

  // We're creating a whole new unitjs testing session within this test...
  //
  // Because of the way stats is shared between the runner and
  // the assertions submodule in UnitJS, trying to use the runner
  // in a nested context can cause problems.
  // So we spawn a copy of the unitjs module here.

  var unitjs = U.spawn();
  var AA = unitjs.assertions;
    // Bad things happen if we use the assertions from the outer
    // unitjs.

  var stmt1='stmt.1';
  var stmt2='stmt.2';
  var stmt3='stmt.3';
  var stmt4='stmt.4';
  var stmt5='stmt.5';
  var sections = new unitjs.Sections();
  var section = new unitjs.Section('s.1');
  var section2 = new unitjs.Section('s.2');
  var section3 = new unitjs.Section('s.3');
  var stats = null;
  var printer = new DummyPrinter();
    // Printers are an independent module so
    // don't bother.

  sections.add(section);
  sections.add(section2);
  section2.subsections.add(section3);

  section.testOrder.push(stmt1);
  section.testOrder.push(stmt2);
  section.testOrder.push(stmt3);
  section2.testOrder.push(stmt4);
  section3.testOrder.push(stmt5);
  section.tests[stmt1] = function(){ AA.assert(true); }
  section.tests[stmt2] = function(){ AA.assert(true);AA.assert(true); }
  section.tests[stmt3] = function(){ AA.assert(false);AA.assert(true); }
  section2.tests[stmt4] = function(){
    AA.assert(true);throw new Error('foo');
  }
  section3.tests[stmt5] = function(){ AA.assert(true); }

  stats = unitjs.runner.sections.run(sections,printer);
    // We should be returned global stats for all sections.

  // We're a bit lazy here since we're testing a whole bunch of things...
  // I should probably break this up into several little tests
  // and put the above prep work into a function.
  // -- DB, Wed Jan 27 14:21:11 EST 2010

  A.assert(stats instanceof unitjs.Stats);
  A.assertEquals(5,stats.tests);
  A.assertEquals(1,stats.failed_tests);
  A.assertEquals(1,stats.errored_tests);
  A.assertEquals(6,stats.assertions);
    // We count the failed assertion but none after it within the test.
    // We count assertions prior to some error within a test.


  // Test stats collated for individual sections...

  A.assertEquals('s.1',sections.members[0].name);
  A.assert(sections.members[0].stats instanceof unitjs.Stats);
  A.assertEquals(3,sections.members[0].stats.tests);
  A.assertEquals(1,sections.members[1].stats.tests);
  A.assertEquals(1,sections.members[1].stats.assertions);
    // This shows that section stats do NOT include
    // subsections.
  A.assertEquals(1,sections.members[1].subsections.members[0].stats.tests);
    // This is a subsection of the above.  It was not included
    // in its parent's stats.
  A.assertEquals(1,sections.members[1].subsections.members[0].stats.assertions);
}




//------------------------------------------------
s = sections.add('setup/teardown');

U.runner.setup = function() { setupChecker.val='setup!'; }
stmt = 'Test setup works at beginning of test';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  A.assertEquals('setup!',setupChecker.val);
}

// To test teardown, we
// - create A.teardown function (which is done prior to any test running)
//   and which modifies a global teardownChecker object if it exists
// - FIRST TEST: create a teardownChecker object
// - SECOND TEST: test that A.teardown is called by checking 
//   teardownChecker has been modified

U.runner.teardown = function() {
  if(teardownChecker) teardownChecker.val='teardown!';
}

stmt = 'Test teardown works at end of test - part 1';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  // Create teardownChecker here.
  teardownChecker = {val:null};  
  A.assertEquals(null,teardownChecker.val);
}

stmt = 'Test teardown works at end of test - part 2';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  // ... and we should be updated here thanks to previous test.
  A.assertEquals('teardown!',teardownChecker.val);
}

// A little weird - this causes an error but pt2 tests that we get what we
// want.

teardownChecker=null;
stmt = 'Test that teardown is called after an error or '+
       'failure in a test - pt1 - CAUSES DELIBERATE ERROR :-) '
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  // Create teardownChecker here.
  teardownChecker = {val:null};  
  U.runner.teardown = function() {
    if(teardownChecker) teardownChecker.val='teardown2!';
  }
  throw new Error('foo');
}

stmt = 'Test that teardown is called after an error or '+
       'failure in a test - pt2 - SHOULD PASS (!) '
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  // ... and we should be updated here thanks to previous test.
  A.assertEquals('teardown2!',teardownChecker.val);
}

stmt = 'Test section setup and teardown is called and called in addition to runner.setup/teardown '
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  var sections = new Sections(),section,printer = new DummyPrinter();
  var obj = {setup:null,teardown:null};  
  var runner_obj = {setup:null,teardown:null};  
  // I'm going to create a new module of unitjs here otherwise
  // we get an error with the STATS object.  The unitjs module currently 
  // assumes there are no nested invocations.
  // -- DBush 15-Jun-09
  var U2 = U.spawn();

  section = sections.add('section 1');
  section.tests['test1'] = function(){};
  section.testOrder.push('test1');
  section.setup = function(){ obj.setup = true; }
  section.teardown = function(){ obj.teardown = true; }
  U2.runner.setup = function(){ runner_obj.setup = true; }
  U2.runner.teardown = function(){ runner_obj.teardown = true; }

  U2.runner.sections.run(sections,printer);
  A.assertEquals(true,obj.setup);
  A.assertEquals(true,obj.teardown);
  A.assertEquals(true,runner_obj.setup);
  A.assertEquals(true,runner_obj.teardown);
}

stmt = 'Test section teardown is still called after a test error'
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  var sections = new Sections(),section,printer = new DummyPrinter();
  var obj = {teardown:null};  
  // I'm going to create a new module of unitjs here otherwise
  // we get an error with the STATS object.  The unitjs module currently 
  // assumes there are no nested invocations.
  // -- DBush 15-Jun-09
  var U2 = U.spawn();

  section = sections.add('section 1');
  section.tests['test1'] = function(){throw new Error('foo');};
  section.testOrder.push('test1');
  section.teardown = function(){ obj.teardown = true; }

  U2.runner.sections.run(sections,printer);
  A.assertEquals(true,obj.teardown);
}

stmt = 'Local teardown function is called on the test '+
       'that sets it and no others';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  var tests={},testOrder=[],printer = new DummyPrinter();
  var U2 = U.spawn();
  var obj = {test1:0};

  tests['test 1'] = function() {
    U2.runner.local.teardown = function() {
      obj.test1++;
    }
  }
  testOrder.push('test 1');
  tests['test 2'] = function(){ }
  testOrder.push('test 2');
  U2.runner.run(testOrder,tests,printer);

  A.assertEquals(1,obj.test1);  // Only incremented once.
}



//------------------------------------------------
s = sections.add('sections');

stmt = 'Calling Sections.add with a string creates and returns a Section object with that name';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  var sections,section;
  sections = new Sections();
  section = sections.add('foo');
  A.assertEquals(section,sections.members[0]);
  A.assertEquals('foo',section.name);
}


stmt = 'Adding a Section object to a Sections object augments members array';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  var sections,section;
  sections = new Sections();
  A.assertEquals(0,sections.members.length);
  section = new Section('section1');
  sections.add(section);
  A.assertEquals(1,sections.members.length);
  A.assertEquals(section,sections.members[0]);

}

stmt = "Adding a Sections object to another Sections object augments members array of the latter";
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  var sections1 = new Sections(),sections2 = new Sections();
  var s1 = new Section('s1'),s2 = new Section('s2'),s3 = new Section('s3');
  sections1.add(s1);
  sections1.add(s2);
  sections2.add(s3);
  sections2.add(sections1);
  A.assertEquals(s3,sections2.members[0]);
  A.assertEquals(s1,sections2.members[1]);
  A.assertEquals(s2,sections2.members[2]);
  A.assertEquals(3,sections2.members.length);
}

stmt = "Adding a subsection sets its parent property to the section"
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  var s,s2,s3,s4,s5,s6;
  var sections = new Sections();
  var sections2 = new Sections();

  // Add using add()...
  s = sections.add('foo');
  s2 = s.subsections.add('bar');
  A.assertEquals(s,s2.parent);

  // Add section instance...
  s3 = new Section('baz');
  s2.subsections.add(s3);
  A.assertEquals(s2,s3.parent);

  // Add sections instance...
  s4 = sections.add('foo2');
  s5 = sections2.add('foo');
  s6 = sections2.add('bar');
  s4.subsections.add(sections2);
  A.assertEquals(s4,s5.parent);
  A.assertEquals(s4,s6.parent);

}


//------------------------------------------------
s = sections.add('empty section');

//------------------------------------------------
s = sections.add('section with tests but no assertions');

stmt = 'no assertions!';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
}

//------------------------------------------------
s = sections.add('section with tests some of which have no assertions');

stmt = 'has assertions 1';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  A.assert(true);
}

stmt = 'has no assertions';
s.testOrder.push(stmt);
s.tests[stmt] = function() {
}


//------------------------------------------------
s = sections.add('section flagged as pending');
s.pending=true;

stmt = 'test with an assertion'
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  A.assert(true);
}


//------------------------------------------------
s = sections.add('section with one test flagged as pending');
stmt = 'test with an assertion'
s.testOrder.push(stmt);
s.tests[stmt] = function() {
  A.assert(true);
}
s.tests[stmt].pending=true;


//------------------------------------------------
s = sections.add('section with subsection that is flagged as pending');
s2 = s.subsections.add('subsection');
s2.pending=true;
s2.testOrder.push(stmt);
s2.tests[stmt] = function() {
  A.assert(true);
}


//------------------------------------------------
s = sections.add('section with subsection that has one test flagged as pending');
s2 = s.subsections.add('subsection');
s2.testOrder.push(stmt);
s2.tests[stmt] = function() {
  A.assert(true);
}
s2.tests[stmt].pending=true;

//------------------------------------------------
s = sections.add('section with subsection that is empty and marked as pending');
s2 = s.subsections.add('pending empty subsection');
s2.pending=true;

//------------------------------------------------
s = sections.add('section with subsection that has one failed test flagged as pending');
s2 = s.subsections.add('subsection');
s2.testOrder.push(stmt);
s2.tests[stmt] = function() {
  A.assert(false);
}
s2.tests[stmt].pending=true;



//------------------------------------------------
function init() {
  printer = new Printer(document.body);
}

</script>
</head>

<body onload="init();" >
<h1>UnitJS Assertion Tests</h1>

<p>
  This page contains tests for the UnitJS Assertion
  functions.  Basically we're testing ourselves with ourselves.
</p>
<input type="button" onclick="U.runner.sections.run(sections,printer);" value="Run tests" />
<input type="button" onclick="printer.collapse();" value="Collapse all / Reset" />
<input type="button" onclick="printer.expand_sections();" value="Expand" />
<input type="button" onclick="printer.expand();" value="Expand all" />
<input type="button" onclick="printer.expand_failed();" value="Show failed" />
<input type="button" onclick="printer.expand_pending();" value="Show pending" />
</body>
</html>
